# The â€œKilling Spreeâ€ Plan ğŸ”ª (Structured & Brutal)

## ğŸ”¥ PHASE 1: A-problem annihilation (NON-NEGOTIABLE)

A problems should take â‰¤5 minutes each.

What you do:

- Solve 30â€“40 A problems in total

- Categories:

    - String length / frequency

    - Simple math

    - Loops

    - Conditionals

Rule:

â— If an A problem takes more than 10 minutes â†’ STOP â†’ analyze why.

After each problem, ask:

- Was this string?

- Counting?

- Math?

- Pattern?

## ğŸ”¥ PHASE 2: B problems = simulation bootcamp

This is where most of your listed problems live.

#### How to approach EVERY B problem:

**Step 1:** Classify (before coding)

Say it out loud:

â€œThis is simulationâ€
â€œThis is greedyâ€
â€œThis is counting + parityâ€

If you canâ€™t classify it â†’ you donâ€™t understand it yet.

**Step 2:** Manual dry run (MANDATORY)

Take sample input, simulate step-by-step.

Example:

- Coins

- Turns

- Attacks

- Moves

- Operations

If your manual run doesnâ€™t match sample output â†’ DO NOT CODE

**Step 3:** Write dumb code first

- No clever tricks

- No shortcuts

- Just simulate exactly what the problem says

Speed comes after correctness, not before.

Quantity target:

- 20â€“25 B problems

- Focus on:

    - Greedy

    - Simulation

    - Counting

## ğŸ”¥ PHASE 3: Post-mortem discipline (this is where people level up)

After every contest or practice:

For each unsolved problem, write:

- â“ What type was it?

- âŒ Where did I fail?

    - Misread?

    - Logic gap?

    - Implementation bug?

- ğŸ§  What is the ONE lesson?

If you donâ€™t extract lessons, youâ€™re just burning time.


## ğŸ”¥ PHASE 4: Contest execution rules (IMPORTANT)

During contest:

**First 10 minutes:**

- Skim all problems

- Instantly mark:

    - Free A

    - Easy B

    - â€œCome back laterâ€

Order:

1. A

2. Easy B

3. Medium B

4. THEN think about C

Never ego-fight a problem.